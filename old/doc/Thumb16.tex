\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\let\oldemptyset\emptyset
\let\emptyset\varnothing
\usepackage{parskip}
\usepackage{fancyvrb}

\title{Thumb Mode Grammar}
\author{Olivia Lucca Fraser\\B00109376}
\date{\today}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\begin{document}

%% Insert some stuff on the Thumb architecture
%% often stands alone
%% but more frequently occurs intertwined with ARM
%% optimizing for density etc
%% interest bc palimpsest for ROP

\section{Introduction to the Thumb-1 Instruction Set}

In this module, we will be dealing only with the Thumb-1 specification,
according to which all Thumb instructions are uniformly of 16 bits in length.
However, a Thumb-2 specification does now exist, and allows for a combination of 32 and 16 bit instructions. This is a conservative extension of Thumb-1, and I will develop it as a separate module. Once we have fixed the grammar for each, correctly parsing binary code as Thumb-2 should be a fairly simple matter: if a 4-byte pattern matches a Thumb-2 instruction, parse it as Thumb-2, and if not, fall
back to Thumb-1.

Most ARM platforms allow the programmer (or compiler) to alternate freely between ARM and Thumb mode, though certain processors, chiefly intended for use in embedded devices with limited memory resources, operate entirely in Thumb.

The operating mode of the processor -- Thumb or ARM -- is decided by a 1-bit flag in the Current Process Status Register (see ARMCommon.lhs for details). This bit can be flipped in one of several ways: a branch instruction that targets an odd-valued address (one whose least significant bit is 1) will switch to Thumb mode (and round off the last bit of the destination address), the BLX instruction in ARM mode will switch to Thumb mode after setting the PC to the target address (while its counterpart, the BLX instruction in Thumb mode, does the opposite), and, finally, the CSPR can be modified directly, using a special set of instructions.

\section{Format of the Thumb Instruction: Overview}

\begin{Verbatim}[fontsize=\scriptsize]
   15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
  +---+---+---+-------+-------------------+-----------+-----------+
1 \ensuremath{\mathrm{0}} 0 \ensuremath{\mathrm{0}}  Op   \ensuremath{\Conid{Offset5}}   Rs      \ensuremath{\Conid{Rd}} Move shifted register
2 \ensuremath{\mathrm{0}} 0 \ensuremath{\mathrm{0}} 1 \ensuremath{\mathrm{1}} I \ensuremath{\Conid{Op}}  Rn/offs3 \ensuremath{\Conid{Rs}}     Rd    \ensuremath{\Conid{Add}\mathbin{/}\Varid{subtract}\;\mathrm{3}} 0 \ensuremath{\mathrm{0}} 1 \ensuremath{\Conid{Op}}    Rd     \ensuremath{\Conid{Offset8}} Move/compare/add/subtract immediate
4 \ensuremath{\mathrm{0}} 1 \ensuremath{\mathrm{0}} 0 \ensuremath{\mathrm{0}} 0 \ensuremath{\Conid{Op}}   Rs      \ensuremath{\Conid{Rd}} ALU operations
5 \ensuremath{\mathrm{0}} 1 \ensuremath{\mathrm{0}} 0 \ensuremath{\mathrm{0}} 1 \ensuremath{\Conid{Op}} H1\ensuremath{\Conid{H2}}  Rs/Hs    \ensuremath{\Conid{Rd}\mathbin{/}\Conid{Hd}} High register operations/branch exchange
6 \ensuremath{\mathrm{0}} 1 \ensuremath{\mathrm{0}} 0 \ensuremath{\mathrm{1}}     Rd    \ensuremath{\Conid{Word8}} PC-relative load
7 \ensuremath{\mathrm{0}} 1 \ensuremath{\mathrm{0}} 1 \ensuremath{\Conid{L}} B \ensuremath{\mathrm{0}}    Ro     \ensuremath{\Conid{Rb}}    Rd     \ensuremath{\Conid{Load}\mathbin{/}\Varid{store}\;\Varid{with}\;\Varid{register}\;\Varid{offset}\;\mathrm{8}} 0 \ensuremath{\mathrm{1}} 0 \ensuremath{\mathrm{1}} H \ensuremath{\Conid{S}} 1 \ensuremath{\Conid{Ro}}    Rb     \ensuremath{\Conid{Rd}} Load/store sign-extended byte/halfword
9 \ensuremath{\mathrm{0}} 1 \ensuremath{\mathrm{1}} B \ensuremath{\Conid{L}}   Offset5         \ensuremath{\Conid{Rb}}    Rd     \ensuremath{\Conid{Load}\mathbin{/}\Varid{store}\;\Varid{with}\;\Varid{immediate}\;\Varid{offset}\;\mathrm{10}} 1 \ensuremath{\mathrm{0}} 0 \ensuremath{\mathrm{0}} L \ensuremath{\Conid{Offset5}}    Rb     \ensuremath{\Conid{Rd}} Load/store halfword
11\ensuremath{\mathrm{1}} 0 \ensuremath{\mathrm{0}} 1 \ensuremath{\Conid{L}}     Rd    \ensuremath{\Conid{Word8}} SP-relative load/store
12\ensuremath{\mathrm{1}} 0 \ensuremath{\mathrm{1}} 0 \ensuremath{\Conid{SP}}     Rd    \ensuremath{\Conid{Word8}} Load address
13\ensuremath{\mathrm{1}} 0 \ensuremath{\mathrm{1}} 1 \ensuremath{\mathrm{0}} 0 \ensuremath{\mathrm{0}} 0 \ensuremath{\Conid{S}}          SWord7           \ensuremath{\Conid{Add}\;\Varid{offset}\;\Varid{to}\;\Varid{stack}\;\Varid{pointer}\;\mathrm{14}} 1 \ensuremath{\mathrm{0}} 1 \ensuremath{\mathrm{1}} L \ensuremath{\mathrm{1}} 0 \ensuremath{\Conid{R}}            Rlist              \ensuremath{\Conid{Push}\mathbin{/}\Varid{pop}\;\Varid{registers}\;\mathrm{15}} 1 \ensuremath{\mathrm{1}} 0 \ensuremath{\mathrm{0}} L \ensuremath{\Conid{Rb}}            Rlist              \ensuremath{\Conid{Multiple}\;\Varid{load}\mathbin{/}\Varid{store}\;\mathrm{16}} 1 \ensuremath{\mathrm{1}} 0 \ensuremath{\mathrm{1}}     Cond      \ensuremath{\Conid{Soffset8}} Conditional branch
17\ensuremath{\mathrm{1}} 1 \ensuremath{\mathrm{0}} 1 \ensuremath{\mathrm{1}} 1 \ensuremath{\mathrm{1}} 1 \ensuremath{\Conid{Value8}} Software Interrupt
18\ensuremath{\mathrm{1}} 1 \ensuremath{\mathrm{1}} 0 \ensuremath{\mathrm{0}}              Offset11                     \ensuremath{\Conid{Unconditional}\;\Varid{branch}\;\mathrm{19}} 1 \ensuremath{\mathrm{1}} 1 \ensuremath{\mathrm{1}} H \ensuremath{\Conid{Offset11}} Long branch with link
  +---+---+---+---+---+-------------------------------------------+
    15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
\end{lstlisting}

\section{Imports}

The modules we'll need to import here are by now familiar, if you have already visited the ARM32.lhs or ARMCommon.lhs modules.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{module}\;\Conid{Thumb16}\;\mathbf{where}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{import}\;\Conid{Aux}{}\<[19]%
\>[19]{}\mbox{\onelinecomment  A grab bag of generally useful, mathematical functions.}{}\<[E]%
\\
\>[B]{}\mathbf{import}\;\Conid{ARMCommon}{}\<[19]%
\>[19]{}\mbox{\onelinecomment  The code that's shared between Thumb16 and ARM32 modules}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{import}\;\Conid{\Conid{Data}.Word}{}\<[19]%
\>[19]{}\mbox{\onelinecomment  standard module for working with fixed width ints}{}\<[E]%
\\
\>[B]{}\mathbf{import}\;\Conid{\Conid{Data}.Bits}{}\<[19]%
\>[19]{}\mbox{\onelinecomment  standard module for doing bitwise arithmetic}{}\<[E]%
\\
\>[B]{}\mathbf{import}\;\Conid{\Conid{Data}.List}{}\<[19]%
\>[19]{}\mbox{\onelinecomment  standard module for list manipulation}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mbox{\onelinecomment  We'll refactor the parsing engine out to a separate module}{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  import Control.Applicative}{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  import qualified Data.List as L}{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  import qualified Data.ByteString as B}{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  import Data.Attoparsec.ByteString}{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  import Data.Attoparsec.Binary}{}\<[E]%
\\
\>[B]{}\mathbf{import}\;\Conid{Numeric}\;(\Varid{showHex}){}\<[27]%
\>[27]{}\mbox{\onelinecomment  for displaying hexidecimal numbers, for debugging}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Data Types for the Thumb Grammar}

Here's where we begin analysing the Thumb-1 grammar. Like the ARM instruction set, Thumb-1 uses a relatively small number of distinct layouts which tell us where to find each of the fields (source register, destination register, opcode, etc.) that we're interested in. 

Each layout is distinguished by an irregular signature of constant bits, which it will be the job of our \textt{whatLayout} function to match.

The Layout type is a compound, or what Haskellers call `algebraic`, data type, and each instance varies somewhat in the information it bundles together with the layout identifier. Typically, an opcode will be included in the form of an instance of an Enum type that, in most cases, resembles the usual assembler mnemonic. Sometimes, however, we need to make finer-grained distinctions than the assembler does, and so the mnemonics will often be tagged with suffixes to differentiate, for instance, the addition of 3-bit values or low registers (ADD3), the addition of 8-bit immediate values (ADD8), and addition of high registers (ADDh)). When an immediate value is embedded in the instruction, this may also be wrapped in the layout instance. Source and destination registers are handled separately, as lists of integers.

Once we have extracted the Mnemonic -- a sort of abstract representation of the logical operation the instruction performs, for which we define a handful of predicates to better classify them\footnote{See ARMCommon.lhs} -- we are able to assign a concrete operation to the instruction. This will be a 'live' Haskell function, with which we can perform computations in the Haskell environment. These will give us the ability to, in some minimal sense, virtualize the ARM operations, without needing to run a full emulation, while being able to manipulate them with any higher-order functions we choose. This will give us enough insight into the code -- and the gadgets extracted from that code -- to be able to regiment it as a compiler might, and search for combinations of gadgets that satisfy (perhaps to some degree of approximation) a given, specified function.

The Instruction record type -- the Haskell counterpart to C's structs -- will bring all this together: source list, destination list, layout instance (with mnemonic, preserved for human readability), and effective operation. These will be the units of which gadgets, and by extension ROP-chains, are composed.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Layout}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{MoveShiftedRegister}\;\Conid{MSR'Mnemonic}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{Add'Subtract}\;\Conid{AS'Mnemonic}\;\Conid{Bool}{}\<[37]%
\>[37]{}\mbox{\onelinecomment  True if immediate value, False if reg}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{MCAS'Immediate}\;\Conid{MCASI'Mnemonic}\;\Conid{Word8}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{ALU'Operations}\;\Conid{ALU'Mnemonic}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{HighRegOp'BX}\;\Conid{HROBX'Mnemonic}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{PCRelativeLoad}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{Load'StoreRegisterOffset}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{Load'StoreSignExtendedByte'Halfword}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{Load'StoreImmediateOffset}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{Load'StoreHalfword}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{SPRelativeLoad'Store}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{LoadAddress}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{AddOffsetToStackPointer}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{Push'PopRegisters}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{MultipleLoad'Store}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{ConditionalBranch}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{SoftwareInterrupt}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{UnconditionalBranch}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{LongBranchWithLink}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{RAWDATA}\;\mathbf{deriving}\;(\Conid{Eq},\Conid{Show}){}\<[E]%
\\
\>[B]{}\mathbf{instance}\;\Conid{Format}\;\Conid{Layout}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Conid{MSR'Mnemonic}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{M'LSL}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{M'LSR}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{M'ASR}\;\mathbf{deriving}\;(\Conid{Show},\Conid{Enum},\Conid{Eq}){}\<[E]%
\\
\>[B]{}\mathbf{instance}\;\Conid{Mnemonic}\;\Conid{MSR'Mnemonic}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Conid{AS'Mnemonic}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ADD3}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{SUB3}\;\mathbf{deriving}\;(\Conid{Show},\Conid{Enum},\Conid{Eq}){}\<[E]%
\\
\>[B]{}\mathbf{instance}\;\Conid{Mnemonic}\;\Conid{AS'Mnemonic}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{additive}\;\Conid{ADD3}\mathrel{=}\Conid{True}{}\<[26]%
\>[26]{}\mbox{\onelinecomment  example of mnemonic predicates}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{additive}\;\Conid{SUB3}\mathrel{=}\Conid{False}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Conid{ALU'Mnemonic}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{AND}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{EOR}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{LSL}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{LSR}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{ASR}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{ADC}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{SBC}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{ROR}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{TST}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{NEG}\;\mathbf{deriving}\;(\Conid{Show},\Conid{Enum},\Conid{Eq}){}\<[E]%
\\
\>[B]{}\mathbf{instance}\;\Conid{Mnemonic}\;\Conid{ALU'Mnemonic}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{additive}\;\Conid{ADC}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{additive}\;\anonymous {}\<[16]%
\>[16]{}\mathrel{=}\Conid{False}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{writeR}\;{}\<[12]%
\>[12]{}\Conid{TST}\mathrel{=}\Conid{False}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{setCPSR}\;{}\<[12]%
\>[12]{}\anonymous {}\<[16]%
\>[16]{}\mathrel{=}\Conid{True}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Conid{MCASI'Mnemonic}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Conid{MOV8}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Conid{CMP8}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Conid{ADD8}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Conid{SUB8}\;\mathbf{deriving}\;(\Conid{Show},\Conid{Enum},\Conid{Eq}){}\<[E]%
\\
\>[B]{}\mathbf{instance}\;\Conid{Mnemonic}\;\Conid{MCASI'Mnemonic}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{additive}\;\Conid{ADD8}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{additive}\;\anonymous {}\<[17]%
\>[17]{}\mathrel{=}\Conid{False}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{writeR}\;{}\<[12]%
\>[12]{}\Conid{CMP8}\mathrel{=}\Conid{False}{}\<[27]%
\>[27]{}\mbox{\onelinecomment  comparison ops don't write to destination register}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{setCPSR}\;{}\<[12]%
\>[12]{}\anonymous {}\<[17]%
\>[17]{}\mathrel{=}\Conid{True}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mbox{\onelinecomment  Mnemonics for High Register Operations / Branch Exchange instructions}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{HROBX'Mnemonic}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ADDh}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{CMPh}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{MOVh}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Conid{BXh}\;\mathbf{deriving}\;(\Conid{Show},\Conid{Enum},\Conid{Eq}){}\<[E]%
\\
\>[B]{}\mathbf{instance}\;\Conid{Mnemonic}\;\Conid{HROBX'Mnemonic}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{additive}\;\Conid{ADDh}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{additive}\;\anonymous {}\<[17]%
\>[17]{}\mathrel{=}\Conid{False}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{writeR}\;{}\<[12]%
\>[12]{}\Conid{CMPh}\mathrel{=}\Conid{False}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{setCPSR}\;{}\<[12]%
\>[12]{}\Conid{CMPh}\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{ctrlFlow}\;\Conid{BXh}{}\<[17]%
\>[17]{}\mathrel{=}\Conid{True}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mbox{\onelinecomment  As I piece-by-piece implement the different operations associated}{}\<[E]%
\\
\>[B]{}\mbox{\onelinecomment  with each layout, I'll add the required fields to each Layout type entry}{}\<[E]%
\\
\>[B]{}\Varid{whatLayout}\mathbin{::}\Conid{Word16}\to \Conid{Layout}{}\<[E]%
\\
\>[B]{}\Varid{whatLayout}\;\Varid{w}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{8}\;\mathrm{16}{}\<[18]%
\>[18]{}\equiv \mathrm{0}\;\Varid{xDF}\mathrel{=}\Conid{SoftwareInterrupt}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{8}\;\mathrm{16}{}\<[18]%
\>[18]{}\equiv \mathrm{0}\;\Varid{xB0}\mathrel{=}\Conid{AddOffsetToStackPointer}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{10}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x08}\mathrel{=}\Conid{ALU'Operations}\;(\Varid{en}\mathbin{\$}\Varid{mask}\;\Varid{w}\;\mathrm{6}\;\mathrm{10}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{10}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x09}\mathrel{=}\Conid{HighRegOp'BX}\;(\Varid{en}\mathbin{\$}\Varid{mask}\;\Varid{w}\;\mathrm{8}\;\mathrm{10}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{11}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x03}\mathrel{=}\Conid{Add'Subtract}\;(\Varid{en}\mathbin{\$}\Varid{testBit}\;\Varid{w}\;\mathrm{9})\;(\Varid{testBit}\;\Varid{w}\;\mathrm{10}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{13}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x00}\mathrel{=}\Conid{MoveShiftedRegister}\;(\Varid{en}\mathbin{\$}\Varid{mask}\;\Varid{w}\;\mathrm{11}\;\mathrm{13}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{13}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x01}\mathrel{=}\Conid{MCAS'Immediate}\;(\Varid{en}\mathbin{\$}\Varid{mask}\;\Varid{w}\;\mathrm{11}\;\mathrm{13})\mathbin{\$}\Varid{en}\mathbin{\$}\Varid{mask}\;\Varid{w}\;\mathrm{0}\;\mathrm{8}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{11}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x09}\mathrel{=}\Conid{PCRelativeLoad}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid (\Varid{mask}\;\Varid{w}\;\mathrm{12}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x05})\mathrel{\wedge}(\Varid{testBit}\;\Varid{w}\;\mathrm{9})\mathrel{=}\Conid{Load'StoreSignExtendedByte'Halfword}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid (\Varid{mask}\;\Varid{w}\;\mathrm{12}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x05})\mathrel{\wedge}(\neg \mathbin{\$}\Varid{testBit}\;\Varid{w}\;\mathrm{9})\mathrel{=}\Conid{Load'StoreRegisterOffset}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{13}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x03}\mathrel{=}\Conid{Load'StoreImmediateOffset}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{12}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x08}\mathrel{=}\Conid{Load'StoreHalfword}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{12}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x09}\mathrel{=}\Conid{SPRelativeLoad'Store}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{12}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x0A}\mathrel{=}\Conid{LoadAddress}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid (\Varid{mask}\;\Varid{w}\;\mathrm{12}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x0B})\mathrel{\wedge}(\Varid{mask}\;\Varid{w}\;\mathrm{9}\;\mathrm{11}\equiv \mathrm{0}\;\Varid{x02})\mathrel{=}\Conid{Push'PopRegisters}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{12}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x0C}\mathrel{=}\Conid{MultipleLoad'Store}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{12}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x0D}\mathrel{=}\Conid{ConditionalBranch}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{11}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x1C}\mathrel{=}\Conid{UnconditionalBranch}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{mask}\;\Varid{w}\;\mathrm{12}\;\mathrm{16}\equiv \mathrm{0}\;\Varid{x0F}\mathrel{=}\Conid{LongBranchWithLink}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{otherwise}\mathrel{=}\Conid{RAWDATA}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Source and Destination Registers}

The following functions will, on the basis of the layout, extract lists of the source and destination registers used by each instruction. Certain instructions in both Thumb and ARM mode have the capacity to read or write from multiple registers at once -- the POP instruction, in Thumb, for instance, and the load and store instructions (LDMI, LDME, STMI, STME) in ARM, have this feature. For this reason, and to avoid unnecessary complexity, we use the [Int] (list of integers) type for source and destination registers, uniformly.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{srcRegs}\mathbin{::}\Conid{Word16}\to [\mskip1.5mu \Conid{Int}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{srcRegs}\;\Varid{w}\mathrel{=}\Varid{map}\;\Varid{fromIntegral}\mathbin{\$}\mathbf{case}\;(\Varid{whatLayout}\;\Varid{w})\;\mathbf{of}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{MoveShiftedRegister}\;\anonymous {}\<[32]%
\>[32]{}\to {}\<[38]%
\>[38]{}[\mskip1.5mu \Varid{mask}\;\Varid{w}\;\mathrm{3}\;\mathrm{6}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Add'Subtract}\;{}\<[23]%
\>[23]{}\anonymous \;{}\<[26]%
\>[26]{}\Conid{False}\to {}\<[38]%
\>[38]{}[\mskip1.5mu \Varid{mask}\;\Varid{w}\;\mathrm{3}\;\mathrm{6},\Varid{mask}\;\Varid{w}\;\mathrm{6}\;\mathrm{9}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Add'Subtract}\;{}\<[23]%
\>[23]{}\anonymous \;{}\<[26]%
\>[26]{}\Conid{True}{}\<[32]%
\>[32]{}\to {}\<[38]%
\>[38]{}[\mskip1.5mu \Varid{mask}\;\Varid{w}\;\mathrm{3}\;\mathrm{6}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ALU'Operations}\;{}\<[23]%
\>[23]{}\anonymous {}\<[32]%
\>[32]{}\to {}\<[38]%
\>[38]{}[\mskip1.5mu \Varid{mask}\;\Varid{w}\;\mathrm{3}\;\mathrm{6}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{MCAS'Immediate}\;{}\<[23]%
\>[23]{}\anonymous \;{}\<[27]%
\>[27]{}\anonymous {}\<[32]%
\>[32]{}\to {}\<[38]%
\>[38]{}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{HighRegOp'BX}\;{}\<[23]%
\>[23]{}\anonymous {}\<[32]%
\>[32]{}\to {}\<[38]%
\>[38]{}[\mskip1.5mu (\Varid{mask}\;\Varid{w}\;\mathrm{3}\;\mathrm{6})\mathbin{`\Varid{shiftL}`}{}\<[E]%
\\
\>[38]{}\hsindent{1}{}\<[39]%
\>[39]{}((\Varid{en}\mathbin{\$}\Varid{testBit}\;\Varid{w}\;\mathrm{6})\mathbin{*}\mathrm{3})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{otherwise}\to [\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{dstRegs}\mathbin{::}\Conid{Word16}\to [\mskip1.5mu \Conid{Int}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{dstRegs}\;\Varid{w}\mathrel{=}\Varid{map}\;\Varid{fromIntegral}\mathbin{\$}\mathbf{case}\;(\Varid{whatLayout}\;\Varid{w})\;\mathbf{of}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{MoveShiftedRegister}\;{}\<[26]%
\>[26]{}\anonymous {}\<[32]%
\>[32]{}\to {}\<[38]%
\>[38]{}[\mskip1.5mu \Varid{mask}\;\Varid{w}\;\mathrm{0}\;\mathrm{3}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Add'Subtract}\;{}\<[26]%
\>[26]{}\anonymous \;{}\<[29]%
\>[29]{}\anonymous {}\<[32]%
\>[32]{}\to {}\<[38]%
\>[38]{}[\mskip1.5mu \Varid{mask}\;\Varid{w}\;\mathrm{0}\;\mathrm{3}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ALU'Operations}\;{}\<[26]%
\>[26]{}\Varid{m}{}\<[32]%
\>[32]{}\to \mathbf{if}\;(\Varid{writeR}\;\Varid{m})\;\mathbf{then}\;[\mskip1.5mu \Varid{mask}\;\Varid{w}\;\mathrm{0}\;\mathrm{3}\mskip1.5mu]\;\mathbf{else}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{MCAS'Immediate}\;{}\<[26]%
\>[26]{}\Varid{m}\;{}\<[29]%
\>[29]{}\anonymous {}\<[32]%
\>[32]{}\to \mathbf{if}\;(\Varid{writeR}\;\Varid{m})\;\mathbf{then}\;[\mskip1.5mu \Varid{mask}\;\Varid{w}\;\mathrm{8}\;\mathrm{11}\mskip1.5mu]\;\mathbf{else}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{HighRegOp'BX}\;{}\<[26]%
\>[26]{}\anonymous {}\<[32]%
\>[32]{}\to {}\<[38]%
\>[38]{}[\mskip1.5mu (\Varid{mask}\;\Varid{w}\;\mathrm{0}\;\mathrm{3})\mathbin{`\Varid{shiftL}`}{}\<[E]%
\\
\>[38]{}\hsindent{1}{}\<[39]%
\>[39]{}((\Varid{en}\mathbin{\$}\Varid{testBit}\;\Varid{w}\;\mathrm{6})\mathbin{*}\mathrm{3})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{otherwise}\to [\mskip1.5mu \mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Extracting the Operation}

One particularly useful (even fundamental) feature of functional programming languages like Haskell is the facility with which they allow the programmer to manipulate functions as 'first class citizens' of the language. We take advantage of this here by decoding the operation that each instruction performs and storing it as live function, which can be used natively in a Haskell environment. These functions each have a peculiar signature, however, which is documented in ARMCommon.lhs, and which sets them apart from garden variety primitives like $+$, $-$, and so on. In the interest of simplifying things, for the compiler, at least, if not for us humans, each operation shares the same, uniform signature: it takes three Wor32 arguments (operand1, operand2, destination register), and returns a pair that contains the CPSR and the value to be written to the destination register. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}c<{\hspost}@{}}%
\column{26E}{@{}l@{}}%
\column{27}{@{}>{\hspre}c<{\hspost}@{}}%
\column{27E}{@{}l@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{49}{@{}>{\hspre}l<{\hspost}@{}}%
\column{61}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{operation}\mathbin{::}\Conid{Word16}\to \Conid{Operation}{}\<[E]%
\\
\>[B]{}\Varid{operation}\;\Varid{w}\mathrel{=}\mathbf{case}\;(\Varid{whatLayout}\;\Varid{w})\;\mathbf{of}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{MoveShiftedRegister}\;\Varid{m}{}\<[26]%
\>[26]{}\to {}\<[26E]%
\>[32]{}\mathbf{let}\;\Varid{sh}\mathrel{=}(\Varid{fromIntegral}\;(\Varid{mask}\;\Varid{w}\;\mathrm{6}\;\mathrm{11})){}\<[E]%
\\
\>[32]{}\mathbf{in}\;\mathbf{case}\;\Varid{m}\;\mathbf{of}{}\<[E]%
\\
\>[32]{}\hsindent{3}{}\<[35]%
\>[35]{}\Conid{M'LSL}\to \lambda \Varid{c}\;\Varid{s}\;\anonymous \;\anonymous \to (\Varid{c},(\Varid{shiftL}\;\Varid{s}\;\Varid{sh})){}\<[E]%
\\
\>[32]{}\hsindent{3}{}\<[35]%
\>[35]{}\Conid{M'LSR}\to \lambda \Varid{c}\;\Varid{s}\;\anonymous \;\anonymous \to (\Varid{c},(\Varid{shiftR}\;\Varid{s}\;\Varid{sh})){}\<[E]%
\\
\>[32]{}\hsindent{3}{}\<[35]%
\>[35]{}\Conid{M'ASR}\to \lambda \Varid{c}\;\Varid{s}\;\anonymous \;\anonymous \to (\Varid{c},(\Varid{aShiftR}\;\Varid{s}\;\Varid{sh})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{ALU'Operations}\;\Varid{m}{}\<[27]%
\>[27]{}\to {}\<[27E]%
\>[33]{}\mathbf{case}\;\Varid{m}\;\mathbf{of}{}\<[E]%
\\
\>[33]{}\hsindent{1}{}\<[34]%
\>[34]{}\Conid{AND}\to \Varid{op'}\;(\mathbin{.\&.})\;\Conid{True}{}\<[E]%
\\
\>[33]{}\hsindent{1}{}\<[34]%
\>[34]{}\Conid{EOR}\to \Varid{op'}\;\Varid{xor}\;\Conid{True}{}\<[E]%
\\
\>[33]{}\hsindent{1}{}\<[34]%
\>[34]{}\Conid{LSL}\to \Varid{op'}\;\Varid{shiftL}\;\Conid{True}{}\<[E]%
\\
\>[33]{}\hsindent{1}{}\<[34]%
\>[34]{}\Conid{LSR}\to \Varid{op'}\;\Varid{shiftR}\;\Conid{True}{}\<[E]%
\\
\>[33]{}\hsindent{1}{}\<[34]%
\>[34]{}\Conid{ASR}\to \Varid{op'}\;\Varid{aShiftR}\;\Conid{True}{}\<[E]%
\\
\>[33]{}\hsindent{1}{}\<[34]%
\>[34]{}\Conid{ADC}\to \Varid{cOp}\;\Conid{ADC}{}\<[E]%
\\
\>[33]{}\hsindent{1}{}\<[34]%
\>[34]{}\Conid{SBC}\to \Varid{cOp}\;\Conid{SBC}{}\<[E]%
\\
\>[33]{}\hsindent{1}{}\<[34]%
\>[34]{}\Conid{ROR}\to \Varid{op'}\;\Varid{rotateR}\;\Conid{True}{}\<[E]%
\\
\>[33]{}\hsindent{1}{}\<[34]%
\>[34]{}\Conid{TST}\to \Varid{op'}\;(\mathbin{.\&.})\;\Conid{False}{}\<[E]%
\\
\>[33]{}\hsindent{1}{}\<[34]%
\>[34]{}\Conid{NEG}\to \Varid{op'}\;(\mathbin{\char92 \char95 }\Varid{s}\to \Varid{negate}\;\Varid{s})\;\Conid{True}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Add'Subtract}\;\Varid{m}\;\Varid{i}{}\<[26]%
\>[26]{}\to {}\<[26E]%
\>[32]{}\mathbf{case}\;\Varid{m}\;\mathbf{of}{}\<[E]%
\\
\>[32]{}\hsindent{2}{}\<[34]%
\>[34]{}\Conid{ADD3}\to \Varid{cOp}\;\Conid{ADD3}{}\<[E]%
\\
\>[32]{}\hsindent{2}{}\<[34]%
\>[34]{}\Conid{SUB3}\to \Varid{cOp}\;\Conid{SUB3}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{MCAS'Immediate}\;\Varid{m}\;\Varid{val}\to {}\<[28]%
\>[28]{}\mathbf{let}\;\Varid{v}\mathbin{::}\Conid{Word32}{}\<[E]%
\\
\>[28]{}\hsindent{4}{}\<[32]%
\>[32]{}\Varid{v}\mathrel{=}{}\<[37]%
\>[37]{}\Varid{en}\;\Varid{val}{}\<[E]%
\\
\>[28]{}\mathbf{in}\;\mathbf{case}\;\Varid{m}\;\mathbf{of}{}\<[E]%
\\
\>[28]{}\Conid{MOV8}\to \mathbin{\char92 \char95 }\anonymous \;\anonymous \;\anonymous \to (\Varid{aspr}\mathbin{\$}\Varid{setNZFlags}\;\Varid{v}{}\<[E]%
\\
\>[28]{}\hsindent{21}{}\<[49]%
\>[49]{},\Varid{v}){}\<[E]%
\\
\>[28]{}\Conid{CMP8}\to \lambda \Varid{c}\;\Varid{d}\;\Varid{s}\;\Varid{n}\to (\Varid{op'}\;(\mathbin{-})\;\Conid{False})\;\Varid{c}\;\Varid{d}\;\Varid{v}\;\Varid{d}{}\<[E]%
\\
\>[28]{}\Conid{ADD8}\to \lambda \Varid{c}\;\Varid{d}\;\Varid{s}\;\Varid{n}\to (\Varid{cOp}\;\Conid{ADD8})\;\Varid{c}\;\Varid{d}\;\Varid{v}\;\Varid{d}{}\<[E]%
\\
\>[28]{}\Conid{SUB8}\to \lambda \Varid{c}\;\Varid{d}\;\Varid{s}\;\Varid{n}\to (\Varid{cOp}\;\Conid{SUB8})\;\Varid{c}\;\Varid{d}\;\Varid{v}\;\Varid{d}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{otherwise}{}\<[26]%
\>[26]{}\to {}\<[26E]%
\>[32]{}\bot {}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{op'}\mathbin{::}(\Conid{Int}\to \Conid{Int}\to \Conid{Int})\to \Conid{Bool}\to \Conid{Operation}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{op'}\;\Varid{oper}\;\Varid{effective}\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{c}\;\Varid{d}\;\Varid{s}\;\Varid{n}\to \mathbf{let}\;\Varid{res}{}\<[28]%
\>[28]{}\mathrel{=}\Varid{fromIntegral}\mathbin{\$}(\Varid{fromIntegral}\;\Varid{n}){}\<[E]%
\\
\>[28]{}\hsindent{2}{}\<[30]%
\>[30]{}\mathbin{`\Varid{oper}`}(\Varid{fromIntegral}\;\Varid{s}){}\<[E]%
\\
\>[7]{}\hsindent{16}{}\<[23]%
\>[23]{}\Varid{flgs}\mathrel{=}\Varid{setNZFlags}\;\Varid{res}{}\<[E]%
\\
\>[7]{}\hsindent{12}{}\<[19]%
\>[19]{}\mathbf{in}\;((\Varid{aspr}\;\Varid{flgs}),\mathbf{if}\;\Varid{effective}\;\mathbf{then}\;\Varid{res}\;\mathbf{else}\;\Varid{d}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{cOp}\mathbin{::}\Conid{Mnemonic}\;\Varid{a}\Rightarrow \Varid{a}\to \Conid{Operation}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{cOp}\;\Varid{m}\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\lambda \Varid{c}\;\Varid{d}\;\Varid{s}\;\Varid{n}\to \mathbf{let}\;\Varid{res64}{}\<[30]%
\>[30]{}\mathbin{::}\Conid{Word64}{}\<[E]%
\\
\>[7]{}\hsindent{16}{}\<[23]%
\>[23]{}\Varid{res32}{}\<[30]%
\>[30]{}\mathbin{::}\Conid{Word32}{}\<[E]%
\\
\>[7]{}\hsindent{16}{}\<[23]%
\>[23]{}\Varid{opA}{}\<[30]%
\>[30]{}\mathbin{::}(\Conid{Num}\;\Varid{a},\Conid{Bits}\;\Varid{a})\Rightarrow \Varid{a}\to \Varid{a}\to \Varid{a}{}\<[E]%
\\
\>[7]{}\hsindent{16}{}\<[23]%
\>[23]{}\Varid{opA}{}\<[30]%
\>[30]{}\mathrel{=}(\mathbf{if}\;(\Varid{additive}\;\Varid{m})\;\mathbf{then}\;(\mathbin{+})\;\mathbf{else}\;(\mathbin{-})){}\<[E]%
\\
\>[7]{}\hsindent{16}{}\<[23]%
\>[23]{}\Varid{res64}{}\<[30]%
\>[30]{}\mathrel{=}(\Varid{fromIntegral}\;\Varid{n})\mathbin{`\Varid{opA}`}(\Varid{fromIntegral}\;\Varid{s}){}\<[E]%
\\
\>[30]{}\hsindent{2}{}\<[32]%
\>[32]{}\mathbin{`\Varid{opA}`}(\mathbf{if}\;(\Varid{testFlag}\;\Varid{c}\;\Conid{Cflag})\;\mathbf{then}\;\mathrm{1}\;\mathbf{else}\;\mathrm{0}){}\<[E]%
\\
\>[7]{}\hsindent{16}{}\<[23]%
\>[23]{}\Varid{res32}{}\<[30]%
\>[30]{}\mathrel{=}\Varid{fromIntegral}\;\Varid{res64}{}\<[E]%
\\
\>[7]{}\hsindent{16}{}\<[23]%
\>[23]{}\Varid{flgs}{}\<[30]%
\>[30]{}\mathrel{=}\Varid{setNZFlags}\;\mathrm{32}{}\<[E]%
\\
\>[30]{}\hsindent{2}{}\<[32]%
\>[32]{}\plus (\mathbf{if}\;(\Varid{shiftR}\;\Varid{res32}\;\mathrm{32}\mathbin{>}\mathrm{0})\;\mathbf{then}\;[\mskip1.5mu \Conid{Cflag}\mskip1.5mu]\;\mathbf{else}\;[\mskip1.5mu \mskip1.5mu]){}\<[E]%
\\
\>[30]{}\hsindent{2}{}\<[32]%
\>[32]{}\plus (\mathbf{if}\;(\Varid{overflow}\;\Varid{s}\;\Varid{d}\;\Varid{res32})\;{}\<[61]%
\>[61]{}\mathbf{then}\;[\mskip1.5mu \Conid{Vflag}\mskip1.5mu]\;\mathbf{else}\;[\mskip1.5mu \mskip1.5mu]){}\<[E]%
\\
\>[7]{}\hsindent{12}{}\<[19]%
\>[19]{}\mathbf{in}\;((\Varid{aspr}\;\Varid{flgs}),\Varid{res32}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
